<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>AR Chemical Experiment – Visible Liquid Transfer</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>

  <!-- AR.js -->
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/aframe/build/aframe-ar.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    #hud {
      position: absolute;
      top: 15px;
      left: 15px;
      background: rgba(20, 30, 48, 0.9);
      color: #e0e0e0;
      padding: 15px;
      border-radius: 12px;
      z-index: 1000;
      max-width: 320px;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    .drop-counter {
      position: absolute;
      top: 15px;
      right: 15px;
      background: rgba(0, 100, 200, 0.9);
      color: white;
      padding: 12px 18px;
      border-radius: 12px;
      z-index: 1000;
      font-weight: 600;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: 0 4px 16px rgba(0, 100, 200, 0.2);
    }
    h3 {
      margin: 0 0 12px 0;
      color: #4dabf7;
      font-weight: 600;
      font-size: 18px;
      border-bottom: 1px solid rgba(77, 171, 247, 0.3);
      padding-bottom: 8px;
    }
    .status-label {
      color: #a0aec0;
      font-size: 13px;
      margin-right: 5px;
    }
    .status-value {
      color: #ffffff;
      font-weight: 500;
      font-size: 13px;
    }
    .status-item {
      margin: 6px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .status-badge {
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
    }
    .found {
      background: rgba(72, 187, 120, 0.2);
      color: #48bb78;
    }
    .not-found {
      background: rgba(245, 101, 101, 0.2);
      color: #f56565;
    }
    .pouring {
      background: rgba(66, 153, 225, 0.2);
      color: #4299e1;
    }
    .reaction {
      background: rgba(159, 122, 234, 0.2);
      color: #9f7aea;
    }
    button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      transition: all 0.3s ease;
      width: 100%;
      margin-top: 10px;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }
    button:active {
      transform: translateY(0);
    }
    .reaction-indicator {
      animation: gentlePulse 2s infinite;
    }
    @keyframes gentlePulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.8; }
    }
  </style>

  <script>
    // Liquid levels - Professional starting values
    let levelA = 0.25; // Half full (50% capacity)
    let levelB = 0.1;  // Quarter full (20% capacity)
    let dropCount = 0;
    let activeDrops = [];

    const MIN = 0.05;
    const MAX = 0.3;
    const SPEED = 0.008;

    // State flags
    let tubeAVisible = false;
    let tubeBVisible = false;
    let reactionDone = false;
    let tiltThreshold = 30;
    let lastDropTime = 0;
    const dropInterval = 300;
    
    // Tilt tracking
    let currentPhoneTilt = 0;
    let isPouring = false;
    let reactionAnimationActive = false;
    let reactionParticles = [];
    let isReactionComplete = false;

    // MARKER TRACKING
    AFRAME.registerComponent("marker-tracker", {
      schema: { id: { type: "string" } },

      init() {
        this.el.addEventListener("markerFound", () => {
          if (this.data.id === "A") {
            tubeAVisible = true;
            document.getElementById("marker-a-status").textContent = "Detected";
            document.getElementById("marker-a-status").className = "status-badge found";
            updateTubeALiquidVisibility();
          }
          if (this.data.id === "B") {
            tubeBVisible = true;
            document.getElementById("marker-b-status").textContent = "Detected";
            document.getElementById("marker-b-status").className = "status-badge found";
            updateTubeBLiquidVisibility();
          }
          updateStatus();
        });

        this.el.addEventListener("markerLost", () => {
          if (this.data.id === "A") {
            tubeAVisible = false;
            document.getElementById("marker-a-status").textContent = "Not Found";
            document.getElementById("marker-a-status").className = "status-badge not-found";
          }
          if (this.data.id === "B") {
            tubeBVisible = false;
            document.getElementById("marker-b-status").textContent = "Not Found";
            document.getElementById("marker-b-status").className = "status-badge not-found";
          }
          updateStatus();
        });
      }
    });

    // TUBE LIQUID VISIBILITY
    function updateTubeALiquidVisibility() {
      const liquidA = document.querySelector("#liquidA");
      const surfaceA = document.querySelector("#surfaceA");
      if (liquidA && surfaceA) {
        liquidA.setAttribute("height", levelA);
        liquidA.setAttribute("position", `0 ${levelA/2} 0`);
        surfaceA.setAttribute("position", `0 ${levelA} 0`);
      }
    }

    function updateTubeBLiquidVisibility() {
      const liquidB = document.querySelector("#liquidB");
      const surfaceB = document.querySelector("#surfaceB");
      if (liquidB && surfaceB) {
        liquidB.setAttribute("height", levelB);
        liquidB.setAttribute("position", `0 ${levelB/2} 0`);
        surfaceB.setAttribute("position", `0 ${levelB} 0`);
      }
    }

    // REFINED REACTION SYSTEM - Professional effects
    AFRAME.registerComponent("reaction-system", {
      schema: {
        tubeId: { type: "string" }
      },

      init: function () {
        this.el.setAttribute('rotation', '0 0 0');
        
        // Animation properties
        this.animationTime = 0;
        this.reactionPhase = 0; // 0=off, 1=active, 2=continuous
        this.colorCycle = 0;
        
        // Professional color palette
        this.reactionColors = [
          '#4dabf7', '#339af0', '#228be6', '#1c7ed6',
          '#15aabf', '#0ca678', '#40c057', '#82c91e',
          '#fab005', '#fd7e14', '#fa5252', '#e64980'
        ];
      },

      tick: function () {
        // Continuous gentle animation when reaction is complete
        if (this.reactionPhase === 2) {
          this.animationTime += 0.02;
          this.colorCycle += 0.01;
          
          // Subtle floating motion
          const floatOffset = Math.sin(this.animationTime) * 0.015;
          const currentPos = this.el.getAttribute('position');
          this.el.setAttribute('position', {
            x: currentPos.x,
            y: currentPos.y + floatOffset,
            z: currentPos.z
          });
          
          // Gentle rotation
          this.el.setAttribute('rotation', {
            x: Math.sin(this.animationTime * 0.3) * 2,
            y: this.animationTime * 8,
            z: Math.cos(this.animationTime * 0.3) * 2
          });
          
          // Update liquid colors with smooth transitions
          this.updateReactionLiquids();
          
        } 
        // Active reaction animation - Refined and professional
        else if (this.reactionPhase === 1) {
          this.animationTime += 0.12;
          
          // Controlled oscillation
          const oscillation = Math.sin(this.animationTime * 2) * 8;
          const gentleShake = Math.sin(this.animationTime * 5) * 3;
          
          this.el.setAttribute('rotation', {
            x: oscillation + gentleShake,
            y: Math.sin(this.animationTime * 1.2) * 5,
            z: 0
          });
          
          // Subtle pulsing scale
          const pulseScale = 1 + Math.sin(this.animationTime * 3) * 0.04;
          this.el.setAttribute('scale', {
            x: pulseScale,
            y: pulseScale,
            z: pulseScale
          });
          
          // Professional color progression
          const colorProgress = (this.animationTime * 20) % 360;
          this.updateReactionColors(colorProgress);
        }
      },

      updateReactionLiquids: function () {
        const liquidA = document.querySelector("#liquidA");
        const liquidB = document.querySelector("#liquidB");
        
        if (liquidA && liquidB) {
          const hue = (this.colorCycle * 180) % 360;
          const saturation = 70;
          const lightness = 55;
          
          liquidA.setAttribute('color', `hsl(${hue}, ${saturation}%, ${lightness}%)`);
          liquidA.setAttribute('emissive', `hsl(${hue}, ${saturation}%, ${lightness}%)`);
          liquidA.setAttribute('emissive-intensity', 0.2);
          
          // Complementary color for tube B
          const complementaryHue = (hue + 180) % 360;
          liquidB.setAttribute('color', `hsl(${complementaryHue}, ${saturation}%, ${lightness}%)`);
          liquidB.setAttribute('emissive', `hsl(${complementaryHue}, ${saturation}%, ${lightness}%)`);
          liquidB.setAttribute('emissive-intensity', 0.15);
        }
      },

      updateReactionColors: function (progress) {
        const liquidA = document.querySelector("#liquidA");
        const liquidB = document.querySelector("#liquidB");
        
        if (liquidA && liquidB) {
          // Transition from blue through green to purple
          const hueA = (200 + progress * 0.5) % 360;
          liquidA.setAttribute('color', `hsl(${hueA}, 75%, 50%)`);
          liquidA.setAttribute('emissive', `hsl(${hueA}, 75%, 50%)`);
          liquidA.setAttribute('emissive-intensity', 0.3 + Math.sin(this.animationTime * 4) * 0.2);
          
          // Tube B follows with phase shift
          const hueB = (320 + progress * 0.5) % 360;
          liquidB.setAttribute('color', `hsl(${hueB}, 75%, 50%)`);
          liquidB.setAttribute('emissive', `hsl(${hueB}, 75%, 50%)`);
          liquidB.setAttribute('emissive-intensity', 0.2 + Math.sin(this.animationTime * 3) * 0.15);
        }
      },

      startReaction: function () {
        this.reactionPhase = 1;
        this.animationTime = 0;
        isReactionComplete = false;
        reactionAnimationActive = true;
        
        // Create elegant particle emission
        this.createElegantParticles();
        
        // Add professional lighting
        this.addReactionLighting();
        
        // Start particle system
        this.startParticleSystem();
      },

      transitionToContinuousMode: function () {
        this.reactionPhase = 2;
        reactionAnimationActive = false;
        isReactionComplete = true;
        this.animationTime = 0;
        this.colorCycle = 0;
        
        // Switch to continuous gentle mode
        this.startContinuousMode();
      },

      stopAllEffects: function () {
        this.reactionPhase = 0;
        reactionAnimationActive = false;
        isReactionComplete = false;
        this.stopParticleSystems();
        this.removeReactionLighting();
      },

      createElegantParticles: function () {
        // Create elegant bubble particles
        for (let i = 0; i < 30; i++) {
          setTimeout(() => {
            this.createBubbleParticle(i);
          }, i * 40);
        }
        
        // Create elegant ring effect
        setTimeout(() => this.createEnergyRing(), 200);
      },

      createBubbleParticle: function (index) {
        const colorIndex = Math.floor(Math.random() * 6); // Use first 6 colors for consistency
        const particle = document.createElement("a-sphere");
        particle.setAttribute("radius", "0.012");
        particle.setAttribute("color", this.reactionColors[colorIndex]);
        particle.setAttribute("opacity", "0.7");
        particle.setAttribute("transparent", "true");
        
        const angle = (index / 30) * Math.PI * 2;
        const distance = 0.1 + Math.random() * 0.08;
        
        particle.setAttribute("position", {
          x: Math.cos(angle) * distance,
          y: 0.2 + Math.random() * 0.1,
          z: Math.sin(angle) * distance
        });
        
        particle.setAttribute("light", {
          type: "point",
          color: this.reactionColors[colorIndex],
          intensity: 0.3,
          distance: 0.2
        });
        
        this.el.appendChild(particle);
        
        reactionParticles.push({
          element: particle,
          velocity: {
            x: Math.cos(angle) * 0.008,
            y: 0.012 + Math.random() * 0.006,
            z: Math.sin(angle) * 0.008
          },
          life: 80 + Math.random() * 40,
          scale: 1
        });
      },

      createEnergyRing: function () {
        const ring = document.createElement("a-ring");
        ring.setAttribute("radius-inner", "0.12");
        ring.setAttribute("radius-outer", "0.15");
        ring.setAttribute("color", "#4dabf7");
        ring.setAttribute("opacity", "0.6");
        ring.setAttribute("position", "0 0.25 0");
        ring.setAttribute("rotation", "-90 0 0");
        ring.setAttribute("transparent", "true");
        
        this.el.appendChild(ring);
        
        // Animate ring expansion
        let scale = 1;
        let opacity = 0.6;
        const animateRing = () => {
          scale += 0.05;
          opacity -= 0.02;
          
          ring.setAttribute("scale", `${scale} ${scale} ${scale}`);
          ring.setAttribute("opacity", opacity);
          
          if (opacity > 0) {
            requestAnimationFrame(animateRing);
          } else {
            if (ring.parentNode) {
              ring.parentNode.removeChild(ring);
            }
          }
        };
        
        animateRing();
      },

      startParticleSystem: function () {
        this.particleInterval = setInterval(() => {
          if (this.reactionPhase === 1) {
            for (let i = 0; i < 2; i++) {
              this.createReactionParticle();
            }
          }
        }, 150);
      },

      createReactionParticle: function () {
        const colorIndex = Math.floor(Math.random() * 6);
        const particle = document.createElement("a-sphere");
        particle.setAttribute("radius", "0.008");
        particle.setAttribute("color", this.reactionColors[colorIndex]);
        particle.setAttribute("opacity", "0.6");
        particle.setAttribute("transparent", "true");
        
        particle.setAttribute("position", {
          x: (Math.random() - 0.5) * 0.15,
          y: 0.15 + Math.random() * 0.2,
          z: (Math.random() - 0.5) * 0.15
        });
        
        particle.setAttribute("light", {
          type: "point",
          color: this.reactionColors[colorIndex],
          intensity: 0.2,
          distance: 0.15
        });
        
        this.el.appendChild(particle);
        
        reactionParticles.push({
          element: particle,
          velocity: {
            x: (Math.random() - 0.5) * 0.004,
            y: 0.006 + Math.random() * 0.004,
            z: (Math.random() - 0.5) * 0.004
          },
          life: 60 + Math.random() * 30,
          scale: 1
        });
      },

      startContinuousMode: function () {
        this.continuousParticleInterval = setInterval(() => {
          if (this.reactionPhase === 2) {
            this.createGentleParticle();
          }
        }, 500);
      },

      createGentleParticle: function () {
        const colorIndex = Math.floor(Math.random() * this.reactionColors.length);
        const particle = document.createElement("a-sphere");
        particle.setAttribute("radius", "0.006");
        particle.setAttribute("color", this.reactionColors[colorIndex]);
        particle.setAttribute("opacity", "0.4");
        particle.setAttribute("transparent", "true");
        
        const angle = Math.random() * Math.PI * 2;
        const distance = 0.18 + Math.random() * 0.07;
        
        particle.setAttribute("position", {
          x: Math.cos(angle) * distance,
          y: 0.15 + Math.random() * 0.15,
          z: Math.sin(angle) * distance
        });
        
        this.el.appendChild(particle);
        
        reactionParticles.push({
          element: particle,
          velocity: {
            x: Math.cos(angle) * 0.001,
            y: 0.003,
            z: Math.sin(angle) * 0.001
          },
          life: 100 + Math.random() * 50,
          scale: 1
        });
      },

      addReactionLighting: function () {
        // Subtle ambient glow
        this.reactionLight = document.createElement("a-light");
        this.reactionLight.setAttribute("type", "point");
        this.reactionLight.setAttribute("color", "#4dabf7");
        this.reactionLight.setAttribute("intensity", "0.5");
        this.reactionLight.setAttribute("distance", "1.5");
        this.reactionLight.setAttribute("position", "0 0.4 0");
        this.el.appendChild(this.reactionLight);
        
        // Gentle fill light
        this.fillLight = document.createElement("a-light");
        this.fillLight.setAttribute("type", "point");
        this.fillLight.setAttribute("color", "#9f7aea");
        this.fillLight.setAttribute("intensity", "0.3");
        this.fillLight.setAttribute("distance", "1.2");
        this.fillLight.setAttribute("position", "0.2 0.35 0.2");
        this.el.appendChild(this.fillLight);
      },

      removeReactionLighting: function () {
        if (this.reactionLight && this.reactionLight.parentNode) {
          this.reactionLight.parentNode.removeChild(this.reactionLight);
        }
        if (this.fillLight && this.fillLight.parentNode) {
          this.fillLight.parentNode.removeChild(this.fillLight);
        }
      },

      stopParticleSystems: function () {
        if (this.particleInterval) clearInterval(this.particleInterval);
        if (this.continuousParticleInterval) clearInterval(this.continuousParticleInterval);
        
        reactionParticles.forEach(particle => {
          if (particle.element.parentNode) {
            particle.element.parentNode.removeChild(particle.element);
          }
        });
        reactionParticles = [];
      }
    });

    // PARTICLE ANIMATION SYSTEM
    AFRAME.registerComponent("particle-animator", {
      tick: function () {
        // Update reaction particles
        for (let i = reactionParticles.length - 1; i >= 0; i--) {
          const particle = reactionParticles[i];
          particle.life--;
          
          if (particle.life <= 0) {
            if (particle.element.parentNode) {
              particle.element.parentNode.removeChild(particle.element);
            }
            reactionParticles.splice(i, 1);
            continue;
          }
          
          // Update position
          const pos = particle.element.getAttribute('position');
          particle.element.setAttribute('position', {
            x: pos.x + particle.velocity.x,
            y: pos.y + particle.velocity.y,
            z: pos.z + particle.velocity.z
          });
          
          // Gentle fade out
          const opacity = Math.min(1, particle.life / 50) * 0.6;
          particle.element.setAttribute('opacity', opacity);
          
          // Subtle pulsing
          const pulse = 0.8 + Math.sin(Date.now() * 0.01 + i) * 0.2;
          particle.element.setAttribute('scale', {
            x: pulse,
            y: pulse,
            z: pulse
          });
        }
      }
    });

    // DROPLET SYSTEM
    AFRAME.registerComponent("drop-spawner", {
      init: function () {
        window.addEventListener("deviceorientation", (event) => {
          const tilt = event.beta || 0;
          currentPhoneTilt = tilt;
          const currentTime = Date.now();
          
          document.getElementById("tilt-display").textContent = Math.round(tilt) + '°';
          
          if (tilt > tiltThreshold && tubeAVisible && !reactionDone) {
            isPouring = true;
            
            if (currentTime - lastDropTime > dropInterval) {
              lastDropTime = currentTime;
              this.spawnDrop();
              updateLiquidLevels();
            }
          } else {
            isPouring = false;
          }
          
          if (tilt > 40 && tubeAVisible && tubeBVisible && !reactionDone) {
            if (levelA <= MIN + 0.01) {
              triggerReaction();
            }
          }
        });
      },

      spawnDrop: function () {
        dropCount++;
        document.getElementById("drop-count").textContent = dropCount;
        
        const drop = document.createElement("a-sphere");
        drop.setAttribute("radius", "0.02");
        drop.setAttribute("color", "#339af0");
        drop.setAttribute("opacity", "0.85");
        
        const tubeA = document.querySelector("#tubeA");
        if (!tubeA) return;
        
        drop.setAttribute("position", { x: 0, y: levelA + 0.08, z: 0 });
        
        tubeA.appendChild(drop);
        
        const dropId = 'drop-' + Date.now();
        drop.setAttribute('id', dropId);
        activeDrops.push({id: dropId, element: drop});
        
        this.animateDrop(drop, dropId);
      },

      animateDrop: function (drop, dropId) {
        let currentY = levelA + 0.08;
        const velocity = { x: 0, y: -0.012, z: 0 };
        const gravity = 0.0006;
        
        const animate = () => {
          if (!reactionDone) {
            velocity.y -= gravity;
            currentY += velocity.y;
            
            drop.setAttribute("position", {
              x: 0,
              y: currentY,
              z: 0
            });
            
            if (currentY < -0.15) {
              if (drop.parentNode) drop.parentNode.removeChild(drop);
              const index = activeDrops.findIndex(d => d.id === dropId);
              if (index > -1) activeDrops.splice(index, 1);
              return;
            }
            
            requestAnimationFrame(animate);
          } else {
            if (drop.parentNode) drop.parentNode.removeChild(drop);
            const index = activeDrops.findIndex(d => d.id === dropId);
            if (index > -1) activeDrops.splice(index, 1);
          }
        };
        
        requestAnimationFrame(animate);
      }
    });

    // Update liquid levels
    function updateLiquidLevels() {
      if (!tubeAVisible || !tubeBVisible || reactionDone) return;
      
      const liquidA = document.querySelector("#liquidA");
      const liquidB = document.querySelector("#liquidB");
      if (!liquidA || !liquidB) return;

      if (levelA > MIN) {
        levelA -= SPEED * 0.6;
        levelB += SPEED * 0.6;
      }

      levelA = Math.max(MIN, levelA);
      levelB = Math.min(MAX, levelB);

      liquidA.setAttribute("height", levelA);
      liquidA.setAttribute("position", `0 ${levelA / 2} 0`);

      liquidB.setAttribute("height", levelB);
      liquidB.setAttribute("position", `0 ${levelB / 2} 0`);
      
      const surfaceA = document.querySelector("#surfaceA");
      const surfaceB = document.querySelector("#surfaceB");
      if (surfaceA) surfaceA.setAttribute('position', `0 ${levelA} 0`);
      if (surfaceB) surfaceB.setAttribute('position', `0 ${levelB} 0`);
    }

    // Trigger reaction - Professional approach
    function triggerReaction() {
      reactionDone = true;
      
      // Complete the transfer
      levelB = MAX;
      const liquidB = document.querySelector("#liquidB");
      if (liquidB) {
        liquidB.setAttribute("height", levelB);
        liquidB.setAttribute("position", `0 ${levelB / 2} 0`);
        const surfaceB = document.querySelector("#surfaceB");
        if (surfaceB) surfaceB.setAttribute('position', `0 ${levelB} 0`);
      }
      
      // Update status
      document.getElementById("reaction-status").textContent = "Reaction Active";
      document.getElementById("reaction-status").className = "status-badge reaction reaction-indicator";
      
      // Clear all drops
      clearAllDrops();
      
      // Start reaction
      const tubeA = document.querySelector("#tubeA");
      if (tubeA && tubeA.components["reaction-system"]) {
        tubeA.components["reaction-system"].startReaction();
        
        // After 3 seconds, transition to continuous mode
        setTimeout(() => {
          if (tubeA.components["reaction-system"]) {
            tubeA.components["reaction-system"].transitionToContinuousMode();
            document.getElementById("reaction-status").textContent = "Continuous Reaction";
          }
        }, 3000);
      }
    }

    function clearAllDrops() {
      activeDrops.forEach(drop => {
        if (drop.element.parentNode) {
          drop.element.parentNode.removeChild(drop.element);
        }
      });
      activeDrops = [];
    }

    function updateStatus() {
      const status = document.getElementById("experiment-status");
      if (tubeAVisible && tubeBVisible) {
        status.textContent = "Ready for Transfer";
      } else if (tubeAVisible) {
        status.textContent = "Tube A Detected";
      } else if (tubeBVisible) {
        status.textContent = "Tube B Detected";
      } else {
        status.textContent = "Awaiting Markers";
      }
      
      // Update pouring status badge
      const pouringStatus = document.getElementById("pouring-status");
      pouringStatus.textContent = isPouring ? "Active" : "Inactive";
      pouringStatus.className = isPouring ? "status-badge pouring" : "status-badge";
    }

    // Reset function
    window.resetExperiment = function() {
      reactionDone = false;
      dropCount = 0;
      levelA = 0.25;
      levelB = 0.1;
      isPouring = false;
      reactionAnimationActive = false;
      isReactionComplete = false;
      
      // Reset tube A
      const tubeA = document.querySelector("#tubeA");
      if (tubeA) {
        tubeA.setAttribute('rotation', '0 0 0');
        tubeA.setAttribute('scale', '1 1 1');
        tubeA.setAttribute('position', '0 0 0');
        
        if (tubeA.components["reaction-system"]) {
          tubeA.components["reaction-system"].stopAllEffects();
        }
      }
      
      // Reset tube B
      const tubeB = document.querySelector("#tubeB");
      if (tubeB) {
        tubeB.setAttribute('rotation', '0 0 0');
        tubeB.setAttribute('scale', '1 1 1');
        tubeB.setAttribute('position', '0 0 0');
      }
      
      // Reset liquids
      updateTubeALiquidVisibility();
      updateTubeBLiquidVisibility();
      
      // Reset liquid colors
      const liquidA = document.querySelector("#liquidA");
      const liquidB = document.querySelector("#liquidB");
      if (liquidA) {
        liquidA.setAttribute('color', '#339af0');
        liquidA.setAttribute('emissive', '#000000');
        liquidA.setAttribute('emissive-intensity', '0');
      }
      if (liquidB) {
        liquidB.setAttribute('color', '#ffd43b');
        liquidB.setAttribute('emissive', '#000000');
        liquidB.setAttribute('emissive-intensity', '0');
      }
      
      // Clear particles
      clearAllDrops();
      reactionParticles.forEach(p => {
        if (p.element.parentNode) p.element.parentNode.removeChild(p.element);
      });
      reactionParticles = [];
      
      // Update UI
      document.getElementById("drop-count").textContent = "0";
      document.getElementById("reaction-status").textContent = "Not Started";
      document.getElementById("reaction-status").className = "status-badge";
      document.getElementById("pouring-status").textContent = "Inactive";
      document.getElementById("pouring-status").className = "status-badge";
      document.getElementById("tilt-display").textContent = "0°";
      
      updateStatus();
    };

  </script>

</head>

<body style="margin:0; overflow:hidden;">
  <!-- Professional HUD Display -->
  <div id="hud">
    <h3>AR Chemical Experiment</h3>
    
    <div class="status-item">
      <span class="status-label">Status:</span>
      <span class="status-value" id="experiment-status">Awaiting Markers</span>
    </div>
    
    <div class="status-item">
      <span class="status-label">Tilt Angle:</span>
      <span class="status-value" id="tilt-display">0°</span>
    </div>
    
    <div class="status-item">
      <span class="status-label">Transfer:</span>
      <span class="status-badge" id="pouring-status">Inactive</span>
    </div>
    
    <div class="status-item">
      <span class="status-label">Marker A:</span>
      <span class="status-badge not-found" id="marker-a-status">Not Found</span>
    </div>
    
    <div class="status-item">
      <span class="status-label">Marker B:</span>
      <span class="status-badge not-found" id="marker-b-status">Not Found</span>
    </div>
    
    <div class="status-item">
      <span class="status-label">Reaction:</span>
      <span class="status-badge" id="reaction-status">Not Started</span>
    </div>
    
    <button onclick="resetExperiment()">
      Reset Experiment
    </button>
  </div>
  
  <!-- Drop Counter -->
  <div class="drop-counter">
    Transfer Drops: <span id="drop-count">0</span>
  </div>

  <a-scene
    embedded
    arjs="debugUIEnabled:false;"
    device-orientation-permission-ui="enabled: true">

    <!-- Professional Lighting -->
    <a-light type="ambient" intensity="0.7" color="#e0e0e0"></a-light>
    <a-light type="directional" position="1 2 1" intensity="0.8" color="#ffffff"></a-light>

    <!-- ========== TEST TUBE A ========= -->
    <a-marker
      type="pattern"
      url="markers/testtube_markerA.patt"
      marker-tracker="id: A">

      <a-entity id="tubeA" drop-spawner reaction-system="tubeId: A" particle-animator position="0 0 0">
        <!-- Glass - Professional look -->
        <a-cylinder
          radius="0.14"
          height="0.5"
          position="0 0.25 0"
          color="#f8f9fa"
          opacity="0.2"
          roughness="0.05"
          metalness="0.8">
        </a-cylinder>

        <!-- Liquid A - Half full initially -->
        <a-cylinder
          id="liquidA"
          radius="0.12"
          height="0.25"
          position="0 0.125 0"
          color="#339af0"
          opacity="0.9"
          roughness="0.1"
          metalness="0.3"
          emissive="#000000"
          emissive-intensity="0"
          transparent="true">
        </a-cylinder>

        <!-- Liquid surface -->
        <a-circle
          id="surfaceA"
          radius="0.12"
          position="0 0.25 0"
          color="#339af0"
          opacity="0.9"
          rotation="-90 0 0"
          transparent="true">
        </a-circle>

      </a-entity>

    </a-marker>

    <!-- ========== TEST TUBE B ========= -->
    <a-marker
      type="pattern"
      url="markers/testtube_markerB.patt"
      marker-tracker="id: B">

      <a-entity id="tubeB" position="0 0 0">
        <!-- Glass -->
        <a-cylinder
          radius="0.14"
          height="0.5"
          position="0 0.25 0"
          color="#f8f9fa"
          opacity="0.2"
          roughness="0.05"
          metalness="0.8">
        </a-cylinder>

        <!-- Liquid B - Small amount initially -->
        <a-cylinder
          id="liquidB"
          radius="0.12"
          height="0.1"
          position="0 0.05 0"
          color="#ffd43b"
          opacity="0.9"
          roughness="0.1"
          metalness="0.3"
          transparent="true">
        </a-cylinder>

        <!-- Liquid surface -->
        <a-circle
          id="surfaceB"
          radius="0.12"
          position="0 0.1 0"
          color="#ffd43b"
          opacity="0.9"
          rotation="-90 0 0"
          transparent="true">
        </a-circle>

      </a-entity>

    </a-marker>

    <!-- Camera -->
    <a-entity camera></a-entity>
  </a-scene>
  
  <script>
    // Update UI
    setInterval(() => {
      updateStatus();
    }, 100);
  </script>
</body>
</html>
