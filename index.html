<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>AR Chemical Mixing ‚Äì Enhanced Reaction & Instant Liquid</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>

  <!-- AR.js -->
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/aframe/build/aframe-ar.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px;
      border-radius: 10px;
      z-index: 1000;
      max-width: 80%;
    }
    .drop-counter {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,100,255,0.8);
      color: white;
      padding: 10px;
      border-radius: 10px;
      z-index: 1000;
    }
    @keyframes rainbow {
      0% { color: #ff0000; }
      16% { color: #ffff00; }
      33% { color: #00ff00; }
      50% { color: #00ffff; }
      66% { color: #0000ff; }
      83% { color: #ff00ff; }
      100% { color: #ff0000; }
    }
    @keyframes rainbowGlow {
      0% { text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000; }
      16% { text-shadow: 0 0 10px #ffff00, 0 0 20px #ffff00; }
      33% { text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00; }
      50% { text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff; }
      66% { text-shadow: 0 0 10px #0000ff, 0 0 20px #0000ff; }
      83% { text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff; }
      100% { text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000; }
    }
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
      20%, 40%, 60%, 80% { transform: translateX(5px); }
    }
  </style>

  <script>
    // Liquid levels - START WITH HALF VISIBLE LIQUID
    let levelA = 0.25; // Half full (was 0.3)
    let levelB = 0.1;  // Small amount visible (was 0.05)
    let dropCount = 0;
    let activeDrops = [];

    const MIN = 0.05;
    const MAX = 0.3;
    const SPEED = 0.008;

    // State flags
    let tubeAVisible = false;
    let tubeBVisible = false;
    let reactionDone = false;
    let tiltThreshold = 30;
    let lastDropTime = 0;
    const dropInterval = 300;
    
    // Tilt tracking
    let currentPhoneTilt = 0;
    let isPouring = false;
    let reactionAnimationActive = false;
    let reactionParticles = [];
    let reactionSparkles = [];
    let isReactionComplete = false;
    let reactionIntensity = 0;

    // MARKER TRACKING
    AFRAME.registerComponent("marker-tracker", {
      schema: { id: { type: "string" } },

      init() {
        this.el.addEventListener("markerFound", () => {
          if (this.data.id === "A") {
            tubeAVisible = true;
            document.getElementById("marker-a-status").textContent = "‚úÖ Found";
            // INSTANTLY SHOW HALF LIQUID IN TUBE A
            updateTubeALiquidVisibility();
          }
          if (this.data.id === "B") {
            tubeBVisible = true;
            document.getElementById("marker-b-status").textContent = "‚úÖ Found";
            // INSTANTLY SHOW SMALL AMOUNT IN TUBE B
            updateTubeBLiquidVisibility();
          }
          updateStatus();
        });

        this.el.addEventListener("markerLost", () => {
          if (this.data.id === "A") {
            tubeAVisible = false;
            document.getElementById("marker-a-status").textContent = "‚ùå Not found";
          }
          if (this.data.id === "B") {
            tubeBVisible = false;
            document.getElementById("marker-b-status").textContent = "‚ùå Not found";
          }
          updateStatus();
        });
      }
    });

    // TUBE LIQUID VISIBILITY - Ensure liquid is instantly visible
    function updateTubeALiquidVisibility() {
      const liquidA = document.querySelector("#liquidA");
      const surfaceA = document.querySelector("#surfaceA");
      if (liquidA && surfaceA) {
        // Half full tube (0.25 height = half of 0.5 max)
        liquidA.setAttribute("height", levelA);
        liquidA.setAttribute("position", `0 ${levelA/2} 0`);
        liquidA.setAttribute("color", "#0088ff");
        liquidA.setAttribute("opacity", "0.95"); // Increased opacity
        liquidA.setAttribute("transparent", "true");
        
        // Surface
        surfaceA.setAttribute("position", `0 ${levelA} 0`);
        surfaceA.setAttribute("color", "#0088ff");
        surfaceA.setAttribute("opacity", "0.95"); // Increased opacity
        surfaceA.setAttribute("transparent", "true");
      }
    }

    function updateTubeBLiquidVisibility() {
      const liquidB = document.querySelector("#liquidB");
      const surfaceB = document.querySelector("#surfaceB");
      if (liquidB && surfaceB) {
        // Small amount in tube B
        liquidB.setAttribute("height", levelB);
        liquidB.setAttribute("position", `0 ${levelB/2} 0`);
        liquidB.setAttribute("color", "#ffff00");
        liquidB.setAttribute("opacity", "0.95"); // Increased opacity
        liquidB.setAttribute("transparent", "true");
        
        // Surface
        surfaceB.setAttribute("position", `0 ${levelB} 0`);
        surfaceB.setAttribute("color", "#ffff00");
        surfaceB.setAttribute("opacity", "0.95"); // Increased opacity
        surfaceB.setAttribute("transparent", "true");
      }
    }

    // ENHANCED REACTION SYSTEM - More dramatic effects
    AFRAME.registerComponent("reaction-system", {
      schema: {
        tubeId: { type: "string" }
      },

      init: function () {
        console.log("Enhanced reaction system initialized for tube:", this.data.tubeId);
        
        // Initial rotation - always straight
        this.el.setAttribute('rotation', '0 0 0');
        
        // Animation properties
        this.currentRotation = 0;
        this.wobbleTime = 0;
        this.reactionIntensity = 0;
        this.rainbowTime = 0;
        this.shakeIntensity = 0;
        this.particleColors = [
          '#ff0000', '#ff5500', '#ffaa00', '#ffff00',
          '#aaff00', '#55ff00', '#00ff55', '#00ffaa',
          '#00ffff', '#00aaff', '#0055ff', '#5500ff',
          '#aa00ff', '#ff00ff', '#ff00aa', '#ff0055'
        ];
        this.currentColorIndex = 0;
        this.colorTransitionTime = 0;
        this.explosionPhase = 0;
      },

      tick: function () {
        // Continuous animation when reaction is complete
        if (isReactionComplete) {
          this.rainbowTime += 0.03;
          this.colorTransitionTime += 0.08;
          
          // Enhanced floating motion
          const floatY = Math.sin(this.rainbowTime) * 0.03;
          const floatX = Math.sin(this.rainbowTime * 1.5) * 0.01;
          const floatZ = Math.cos(this.rainbowTime * 1.5) * 0.01;
          
          const currentPos = this.el.getAttribute('position');
          this.el.setAttribute('position', {
            x: currentPos.x + floatX,
            y: currentPos.y + floatY,
            z: currentPos.z + floatZ
          });
          
          // Enhanced rotation
          this.el.setAttribute('rotation', {
            x: Math.sin(this.rainbowTime * 0.8) * 5,
            y: this.rainbowTime * 15,
            z: Math.cos(this.rainbowTime * 0.8) * 5
          });
          
          // Pulsing scale
          const pulseScale = 1 + Math.sin(this.rainbowTime * 2) * 0.05;
          this.el.setAttribute('scale', {
            x: pulseScale,
            y: pulseScale,
            z: pulseScale
          });
          
          // Continuous color cycling
          if (this.colorTransitionTime >= 1) {
            this.colorTransitionTime = 0;
            this.currentColorIndex = (this.currentColorIndex + 1) % this.particleColors.length;
          }
          
          // Update liquid colors
          this.updateRainbowLiquids();
          
        } 
        // Active reaction animation - MORE DRAMATIC
        else if (reactionAnimationActive) {
          this.wobbleTime += 0.25; // Faster wobble
          this.reactionIntensity = Math.min(1, this.reactionIntensity + 0.05); // Faster intensity increase
          this.shakeIntensity = this.reactionIntensity * 2;
          
          // EXTREME WOBBLING AND SHAKING
          const wobbleAngle = Math.sin(this.wobbleTime * 3) * 35; // Increased angle
          const shakeAngle = Math.sin(this.wobbleTime * 8) * 15; // Faster shake
          const twistAngle = Math.sin(this.wobbleTime * 2) * 20; // Twist effect
          
          this.el.setAttribute('rotation', {
            x: wobbleAngle + shakeAngle,
            y: twistAngle + Math.sin(this.wobbleTime * 2) * 15,
            z: Math.cos(this.wobbleTime * 2) * 15
          });
          
          // VIOLENT PULSING SCALE
          const pulseScale = 1 + Math.sin(this.wobbleTime * 5) * 0.15;
          this.el.setAttribute('scale', {
            x: pulseScale,
            y: pulseScale,
            z: pulseScale
          });
          
          // Position shaking
          const shakeX = Math.sin(this.wobbleTime * 10) * 0.02 * this.shakeIntensity;
          const shakeY = Math.cos(this.wobbleTime * 8) * 0.01 * this.shakeIntensity;
          const currentPos = this.el.getAttribute('position');
          this.el.setAttribute('position', {
            x: currentPos.x + shakeX,
            y: currentPos.y + shakeY,
            z: currentPos.z + shakeX * 0.5
          });
          
          // EXTREME RAINBOW COLOR EFFECT
          const hue = (this.wobbleTime * 100) % 360;
          const liquid = document.querySelector("#liquidA");
          if (liquid) {
            liquid.setAttribute('color', `hsl(${hue}, 100%, 60%)`);
            liquid.setAttribute('emissive', `hsl(${hue}, 100%, 60%)`);
            liquid.setAttribute('emissive-intensity', 0.8 + Math.sin(this.wobbleTime * 8) * 0.4);
            
            // Also make the glass glow
            const glass = document.querySelector("#tubeA a-cylinder");
            if (glass) {
              glass.setAttribute('color', `hsl(${(hue + 60) % 360}, 70%, 80%)`);
              glass.setAttribute('emissive', `hsl(${(hue + 60) % 360}, 50%, 30%)`);
              glass.setAttribute('emissive-intensity', 0.3);
            }
          }
          
          // Tube B also reacts
          const liquidB = document.querySelector("#liquidB");
          if (liquidB) {
            const hueB = (hue + 180) % 360;
            liquidB.setAttribute('color', `hsl(${hueB}, 100%, 60%)`);
            liquidB.setAttribute('emissive', `hsl(${hueB}, 100%, 60%)`);
            liquidB.setAttribute('emissive-intensity', 0.6 + Math.sin(this.wobbleTime * 6) * 0.3);
          }
        }
      },

      updateRainbowLiquids: function () {
        const liquidA = document.querySelector("#liquidA");
        const liquidB = document.querySelector("#liquidB");
        
        if (liquidA && liquidB) {
          // Smooth color transition for Tube A
          const nextColorIndex = (this.currentColorIndex + 1) % this.particleColors.length;
          const currentColor = this.hexToRgb(this.particleColors[this.currentColorIndex]);
          const nextColor = this.hexToRgb(this.particleColors[nextColorIndex]);
          
          const r = Math.floor(currentColor.r + (nextColor.r - currentColor.r) * this.colorTransitionTime);
          const g = Math.floor(currentColor.g + (nextColor.g - currentColor.g) * this.colorTransitionTime);
          const b = Math.floor(currentColor.b + (nextColor.b - currentColor.b) * this.colorTransitionTime);
          
          liquidA.setAttribute('color', `rgb(${r}, ${g}, ${b})`);
          liquidA.setAttribute('emissive', `rgb(${r}, ${g}, ${b})`);
          liquidA.setAttribute('emissive-intensity', 0.5 + Math.sin(this.rainbowTime * 3) * 0.3);
          
          // Tube B complementary color
          const nextColorIndex2 = (this.currentColorIndex + 8) % this.particleColors.length;
          const nextColorIndex3 = (nextColorIndex2 + 1) % this.particleColors.length;
          const currentColor2 = this.hexToRgb(this.particleColors[nextColorIndex2]);
          const nextColor2 = this.hexToRgb(this.particleColors[nextColorIndex3]);
          
          const r2 = Math.floor(currentColor2.r + (nextColor2.r - currentColor2.r) * this.colorTransitionTime);
          const g2 = Math.floor(currentColor2.g + (nextColor2.g - currentColor2.g) * this.colorTransitionTime);
          const b2 = Math.floor(currentColor2.b + (nextColor2.b - currentColor2.b) * this.colorTransitionTime);
          
          liquidB.setAttribute('color', `rgb(${r2}, ${g2}, ${b2})`);
          liquidB.setAttribute('emissive', `rgb(${r2}, ${g2}, ${b2})`);
          liquidB.setAttribute('emissive-intensity', 0.4 + Math.sin(this.rainbowTime * 2.5) * 0.2);
        }
      },

      hexToRgb: function(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : { r: 0, g: 0, b: 0 };
      },

      startReaction: function () {
        reactionAnimationActive = true;
        isReactionComplete = false;
        this.wobbleTime = 0;
        this.reactionIntensity = 0;
        this.rainbowTime = 0;
        this.shakeIntensity = 0;
        
        // SHAKE THE ENTIRE HUD for dramatic effect
        document.getElementById("hud").style.animation = "shake 0.5s";
        
        // Create SUPER DRAMATIC initial effects
        this.createMegaExplosion();
        
        // Start intense particle systems
        this.startIntenseParticleSystem();
        
        // Add dramatic light effect
        this.addSuperReactionLight();
        
        // Play explosion sound effect (if audio available)
        this.playExplosionSound();
      },

      transitionToContinuousMode: function () {
        reactionAnimationActive = false;
        isReactionComplete = true;
        this.rainbowTime = 0;
        this.colorTransitionTime = 0;
        this.currentColorIndex = 0;
        
        // Stop HUD shake
        document.getElementById("hud").style.animation = "";
        
        // Change to continuous gentle effects
        this.startContinuousRainbowMode();
      },

      stopAllEffects: function () {
        reactionAnimationActive = false;
        isReactionComplete = false;
        this.stopParticleSystems();
        this.removeReactionLight();
        document.getElementById("hud").style.animation = "";
      },

      // MEGA EXPLOSION EFFECT
      createMegaExplosion: function () {
        // Multiple expanding rings
        for (let i = 0; i < 3; i++) {
          setTimeout(() => this.createExplosionRing(i), i * 100);
        }
        
        // Massive particle burst
        setTimeout(() => this.createMegaParticleBurst(), 150);
        
        // Shockwave effect
        setTimeout(() => this.createShockwave(), 300);
      },

      createExplosionRing: function (ringIndex) {
        const ring = document.createElement("a-ring");
        const ringColors = ['#ff0000', '#ffff00', '#00ffff'];
        ring.setAttribute("radius-inner", "0.05");
        ring.setAttribute("radius-outer", "0.1");
        ring.setAttribute("color", ringColors[ringIndex % 3]);
        ring.setAttribute("opacity", "1");
        ring.setAttribute("position", "0 0.3 0");
        ring.setAttribute("rotation", "-90 0 0");
        ring.setAttribute("transparent", "true");
        
        ring.setAttribute("light", {
          type: "point",
          color: ringColors[ringIndex % 3],
          intensity: 2,
          distance: 1
        });
        
        this.el.appendChild(ring);
        
        // Explosive expansion
        let scale = 1;
        let opacity = 1;
        const expandSpeed = 0.2 + ringIndex * 0.05;
        const animateRing = () => {
          scale += expandSpeed;
          opacity -= 0.08;
          
          ring.setAttribute("scale", `${scale} ${scale} ${scale}`);
          ring.setAttribute("opacity", opacity);
          
          if (opacity > 0) {
            requestAnimationFrame(animateRing);
          } else {
            if (ring.parentNode) {
              ring.parentNode.removeChild(ring);
            }
          }
        };
        
        animateRing();
      },

      createMegaParticleBurst: function () {
        // Create 100 particles at once!
        for (let i = 0; i < 100; i++) {
          setTimeout(() => {
            this.createExplosionParticle(i);
          }, Math.random() * 50);
        }
      },

      createExplosionParticle: function (index) {
        const colorIndex = Math.floor(Math.random() * this.particleColors.length);
        const particleType = Math.random();
        
        let particle;
        if (particleType < 0.3) {
          particle = document.createElement("a-tetrahedron");
          particle.setAttribute("radius", "0.03");
        } else if (particleType < 0.6) {
          particle = document.createElement("a-octahedron");
          particle.setAttribute("radius", "0.025");
        } else {
          particle = document.createElement("a-sphere");
          particle.setAttribute("radius", "0.02");
        }
        
        particle.setAttribute("color", this.particleColors[colorIndex]);
        particle.setAttribute("opacity", "1");
        particle.setAttribute("transparent", "true");
        
        // Explosive outward motion
        const angle = Math.random() * Math.PI * 2;
        const verticalAngle = (Math.random() - 0.5) * Math.PI;
        const speed = 0.05 + Math.random() * 0.05;
        
        particle.setAttribute("position", {
          x: Math.cos(angle) * 0.05,
          y: 0.3,
          z: Math.sin(angle) * 0.05
        });
        
        particle.setAttribute("rotation", {
          x: Math.random() * 360,
          y: Math.random() * 360,
          z: Math.random() * 360
        });
        
        particle.setAttribute("light", {
          type: "point",
          color: this.particleColors[colorIndex],
          intensity: 1,
          distance: 0.4
        });
        
        this.el.appendChild(particle);
        
        reactionParticles.push({
          element: particle,
          velocity: {
            x: Math.cos(angle) * Math.cos(verticalAngle) * speed,
            y: Math.sin(verticalAngle) * speed,
            z: Math.sin(angle) * Math.cos(verticalAngle) * speed
          },
          life: 100 + Math.random() * 100,
          spinSpeed: 0.1 + Math.random() * 0.1,
          rotation: 0,
          scale: 1,
          rotationSpeed: {
            x: (Math.random() - 0.5) * 0.1,
            y: (Math.random() - 0.5) * 0.1,
            z: (Math.random() - 0.5) * 0.1
          },
          gravity: 0.0002
        });
      },

      createShockwave: function () {
        const shockwave = document.createElement("a-circle");
        shockwave.setAttribute("radius", "0.01");
        shockwave.setAttribute("color", "#ffffff");
        shockwave.setAttribute("opacity", "0.8");
        shockwave.setAttribute("position", "0 0.3 0");
        shockwave.setAttribute("rotation", "-90 0 0");
        shockwave.setAttribute("transparent", "true");
        
        this.el.appendChild(shockwave);
        
        // Shockwave expansion
        let scale = 1;
        let opacity = 0.8;
        const animateShockwave = () => {
          scale += 0.15;
          opacity -= 0.1;
          
          shockwave.setAttribute("radius", scale * 0.2);
          shockwave.setAttribute("opacity", opacity);
          
          if (opacity > 0) {
            requestAnimationFrame(animateShockwave);
          } else {
            if (shockwave.parentNode) {
              shockwave.parentNode.removeChild(shockwave);
            }
          }
        };
        
        animateShockwave();
      },

      // INTENSE PARTICLE SYSTEM
      startIntenseParticleSystem: function () {
        // Initial burst particles
        this.intenseParticleInterval = setInterval(() => {
          if (reactionAnimationActive) {
            for (let i = 0; i < 5; i++) {
              this.createIntenseParticle();
            }
          }
        }, 50);
        
        // Transition to continuous after intense phase
        setTimeout(() => {
          if (this.intenseParticleInterval) clearInterval(this.intenseParticleInterval);
        }, 2000);
      },

      createIntenseParticle: function () {
        const colorIndex = Math.floor(Math.random() * this.particleColors.length);
        const particle = document.createElement("a-sphere");
        particle.setAttribute("radius", "0.015");
        particle.setAttribute("color", this.particleColors[colorIndex]);
        particle.setAttribute("opacity", "0.9");
        particle.setAttribute("transparent", "true");
        
        // Random position around tube
        const angle = Math.random() * Math.PI * 2;
        const distance = 0.1 + Math.random() * 0.2;
        
        particle.setAttribute("position", {
          x: Math.cos(angle) * distance,
          y: 0.2 + Math.random() * 0.3,
          z: Math.sin(angle) * distance
        });
        
        particle.setAttribute("light", {
          type: "point",
          color: this.particleColors[colorIndex],
          intensity: 0.8,
          distance: 0.3
        });
        
        this.el.appendChild(particle);
        
        reactionParticles.push({
          element: particle,
          velocity: {
            x: (Math.random() - 0.5) * 0.01,
            y: 0.01 + Math.random() * 0.01,
            z: (Math.random() - 0.5) * 0.01
          },
          life: 80 + Math.random() * 40,
          spinSpeed: 0.02,
          rotation: 0,
          scale: 1,
          pulseSpeed: 0.05 + Math.random() * 0.03,
          pulsePhase: Math.random() * Math.PI * 2
        });
      },

      // CONTINUOUS RAINBOW MODE
      startContinuousRainbowMode: function () {
        // Continuous gentle particle emission
        this.continuousParticleInterval = setInterval(() => {
          if (isReactionComplete) {
            for (let i = 0; i < 2; i++) {
              this.createGentleRainbowParticle();
            }
          }
        }, 400);
        
        // Continuous sparkle system
        this.continuousSparkleInterval = setInterval(() => {
          if (isReactionComplete) {
            for (let i = 0; i < 3; i++) {
              this.createRainbowSparkle();
            }
          }
        }, 300);
      },

      createGentleRainbowParticle: function () {
        const colorIndex = Math.floor(Math.random() * this.particleColors.length);
        const particle = document.createElement("a-sphere");
        particle.setAttribute("radius", "0.01");
        particle.setAttribute("color", this.particleColors[colorIndex]);
        particle.setAttribute("opacity", "0.7");
        particle.setAttribute("transparent", "true");
        
        const angle = Math.random() * Math.PI * 2;
        const distance = 0.15 + Math.random() * 0.1;
        
        particle.setAttribute("position", {
          x: Math.cos(angle) * distance,
          y: 0.2 + Math.random() * 0.3,
          z: Math.sin(angle) * distance
        });
        
        particle.setAttribute("light", {
          type: "point",
          color: this.particleColors[colorIndex],
          intensity: 0.4,
          distance: 0.2
        });
        
        this.el.appendChild(particle);
        
        reactionParticles.push({
          element: particle,
          velocity: {
            x: (Math.random() - 0.5) * 0.002,
            y: 0.005 + Math.random() * 0.005,
            z: (Math.random() - 0.5) * 0.002
          },
          life: 150 + Math.random() * 100,
          spinSpeed: 0.005,
          rotation: 0,
          scale: 1,
          pulseSpeed: 0.03 + Math.random() * 0.02,
          pulsePhase: Math.random() * Math.PI * 2
        });
      },

      createRainbowSparkle: function () {
        const colorIndex = Math.floor(Math.random() * this.particleColors.length);
        const sparkle = document.createElement("a-cone");
        sparkle.setAttribute("radius-bottom", "0.008");
        sparkle.setAttribute("radius-top", "0.001");
        sparkle.setAttribute("height", "0.015");
        sparkle.setAttribute("color", this.particleColors[colorIndex]);
        sparkle.setAttribute("opacity", "0.8");
        sparkle.setAttribute("transparent", "true");
        
        sparkle.setAttribute("position", {
          x: (Math.random() - 0.5) * 0.4,
          y: 0.1 + Math.random() * 0.5,
          z: (Math.random() - 0.5) * 0.4
        });
        
        sparkle.setAttribute("rotation", {
          x: Math.random() * 360,
          y: Math.random() * 360,
          z: Math.random() * 360
        });
        
        sparkle.setAttribute("light", {
          type: "point",
          color: this.particleColors[colorIndex],
          intensity: 0.3 + Math.random() * 0.4,
          distance: 0.15
        });
        
        this.el.appendChild(sparkle);
        
        reactionSparkles.push({
          element: sparkle,
          life: 60 + Math.random() * 40,
          twinkleSpeed: 0.03 + Math.random() * 0.04,
          twinklePhase: Math.random() * Math.PI * 2,
          scale: 1
        });
      },

      addSuperReactionLight: function () {
        // Multiple intense lights
        this.reactionLight1 = document.createElement("a-light");
        this.reactionLight1.setAttribute("type", "point");
        this.reactionLight1.setAttribute("color", "#ff0000");
        this.reactionLight1.setAttribute("intensity", "2");
        this.reactionLight1.setAttribute("distance", "3");
        this.reactionLight1.setAttribute("position", "0 0.5 0");
        this.el.appendChild(this.reactionLight1);
        
        this.reactionLight2 = document.createElement("a-light");
        this.reactionLight2.setAttribute("type", "point");
        this.reactionLight2.setAttribute("color", "#00ff00");
        this.reactionLight2.setAttribute("intensity", "1.5");
        this.reactionLight2.setAttribute("distance", "2.5");
        this.reactionLight2.setAttribute("position", "0.3 0.4 0.3");
        this.el.appendChild(this.reactionLight2);
        
        this.reactionLight3 = document.createElement("a-light");
        this.reactionLight3.setAttribute("type", "point");
        this.reactionLight3.setAttribute("color", "#0000ff");
        this.reactionLight3.setAttribute("intensity", "1.5");
        this.reactionLight3.setAttribute("distance", "2.5");
        this.reactionLight3.setAttribute("position", "-0.3 0.4 -0.3");
        this.el.appendChild(this.reactionLight3);
        
        // Start light color cycling
        this.lightCycleTime = 0;
      },

      updateLightColors: function () {
        if (!this.reactionLight1) return;
        
        this.lightCycleTime += 0.03;
        const hue1 = (this.lightCycleTime * 40) % 360;
        const hue2 = (hue1 + 120) % 360;
        const hue3 = (hue1 + 240) % 360;
        
        const intensity1 = isReactionComplete ? 0.8 : 1.5 + Math.sin(this.lightCycleTime * 5) * 0.5;
        const intensity2 = isReactionComplete ? 0.6 : 1.2 + Math.sin(this.lightCycleTime * 4) * 0.3;
        const intensity3 = isReactionComplete ? 0.6 : 1.2 + Math.sin(this.lightCycleTime * 3) * 0.3;
        
        this.reactionLight1.setAttribute('color', `hsl(${hue1}, 100%, 60%)`);
        this.reactionLight1.setAttribute('intensity', intensity1);
        
        this.reactionLight2.setAttribute('color', `hsl(${hue2}, 100%, 60%)`);
        this.reactionLight2.setAttribute('intensity', intensity2);
        
        this.reactionLight3.setAttribute('color', `hsl(${hue3}, 100%, 60%)`);
        this.reactionLight3.setAttribute('intensity', intensity3);
      },

      playExplosionSound: function () {
        // Visual explosion effect since audio might not work
        const explosionText = document.createElement("div");
        explosionText.innerHTML = "üí• BOOM! üí•";
        explosionText.style.position = "absolute";
        explosionText.style.top = "50%";
        explosionText.style.left = "50%";
        explosionText.style.transform = "translate(-50%, -50%)";
        explosionText.style.fontSize = "40px";
        explosionText.style.fontWeight = "bold";
        explosionText.style.color = "#ff0000";
        explosionText.style.textShadow = "0 0 20px #ff0000, 0 0 40px #ffff00";
        explosionText.style.zIndex = "2000";
        explosionText.style.animation = "rainbow 0.5s 3";
        document.body.appendChild(explosionText);
        
        // Remove after animation
        setTimeout(() => {
          if (explosionText.parentNode) {
            explosionText.parentNode.removeChild(explosionText);
          }
        }, 1500);
      },

      stopParticleSystems: function () {
        if (this.intenseParticleInterval) clearInterval(this.intenseParticleInterval);
        if (this.continuousParticleInterval) clearInterval(this.continuousParticleInterval);
        if (this.continuousSparkleInterval) clearInterval(this.continuousSparkleInterval);
        
        // Remove all particles
        reactionParticles.forEach(particle => {
          if (particle.element.parentNode) {
            particle.element.parentNode.removeChild(particle.element);
          }
        });
        reactionParticles = [];
        
        // Remove all sparkles
        reactionSparkles.forEach(sparkle => {
          if (sparkle.element.parentNode) {
            sparkle.element.parentNode.removeChild(sparkle.element);
          }
        });
        reactionSparkles = [];
      },

      removeReactionLight: function () {
        if (this.reactionLight1 && this.reactionLight1.parentNode) {
          this.reactionLight1.parentNode.removeChild(this.reactionLight1);
        }
        if (this.reactionLight2 && this.reactionLight2.parentNode) {
          this.reactionLight2.parentNode.removeChild(this.reactionLight2);
        }
        if (this.reactionLight3 && this.reactionLight3.parentNode) {
          this.reactionLight3.parentNode.removeChild(this.reactionLight3);
        }
      }
    });

    // PARTICLE ANIMATION SYSTEM
    AFRAME.registerComponent("particle-animator", {
      tick: function () {
        // Update light colors continuously
        const tubeA = document.querySelector("#tubeA");
        if (tubeA && tubeA.components["reaction-system"]) {
          tubeA.components["reaction-system"].updateLightColors();
        }
        
        // Update reaction particles
        for (let i = reactionParticles.length - 1; i >= 0; i--) {
          const particle = reactionParticles[i];
          particle.life--;
          
          if (particle.life <= 0) {
            if (particle.element.parentNode) {
              particle.element.parentNode.removeChild(particle.element);
            }
            reactionParticles.splice(i, 1);
            continue;
          }
          
          // Update position with gravity
          const pos = particle.element.getAttribute('position');
          if (particle.gravity) {
            particle.velocity.y -= particle.gravity;
          }
          
          particle.element.setAttribute('position', {
            x: pos.x + particle.velocity.x,
            y: pos.y + particle.velocity.y,
            z: pos.z + particle.velocity.z
          });
          
          // Update rotation for spinning particles
          if (particle.rotationSpeed) {
            const rot = particle.element.getAttribute('rotation') || {x: 0, y: 0, z: 0};
            particle.element.setAttribute('rotation', {
              x: rot.x + particle.rotationSpeed.x,
              y: rot.y + particle.rotationSpeed.y,
              z: rot.z + particle.rotationSpeed.z
            });
          }
          
          // Pulsing scale
          if (particle.pulseSpeed) {
            particle.pulsePhase += particle.pulseSpeed;
            const pulse = 0.5 + Math.sin(particle.pulsePhase) * 0.5;
            particle.element.setAttribute('scale', {
              x: pulse,
              y: pulse,
              z: pulse
            });
          }
          
          // Gentle fade out
          const opacity = Math.min(1, particle.life / 50) * 0.7;
          particle.element.setAttribute('opacity', opacity);
        }
        
        // Update sparkles
        for (let i = reactionSparkles.length - 1; i >= 0; i--) {
          const sparkle = reactionSparkles[i];
          sparkle.life--;
          
          if (sparkle.life <= 0) {
            if (sparkle.element.parentNode) {
              sparkle.element.parentNode.removeChild(sparkle.element);
            }
            reactionSparkles.splice(i, 1);
            continue;
          }
          
          sparkle.twinklePhase += sparkle.twinkleSpeed;
          const twinkle = 0.3 + Math.sin(sparkle.twinklePhase) * 0.7;
          
          const light = sparkle.element.getAttribute('light');
          if (light) {
            const color = light.color || "#ffffff";
            sparkle.element.setAttribute('light', {
              type: "point",
              color: color,
              intensity: twinkle * 0.6,
              distance: light.distance || 0.15
            });
          }
          
          sparkle.scale = 0.3 + twinkle * 0.7;
          sparkle.element.setAttribute('scale', {
            x: sparkle.scale,
            y: sparkle.scale,
            z: sparkle.scale
          });
        }
      }
    });

    // DROPLET SYSTEM
    AFRAME.registerComponent("drop-spawner", {
      init: function () {
        console.log("Drop spawner initialized");
        
        window.addEventListener("deviceorientation", (event) => {
          const tilt = event.beta || 0;
          currentPhoneTilt = tilt;
          const currentTime = Date.now();
          
          document.getElementById("tilt-display").textContent = Math.round(tilt) + '¬∞';
          
          if (tilt > tiltThreshold && tubeAVisible && !reactionDone) {
            isPouring = true;
            
            if (currentTime - lastDropTime > dropInterval) {
              lastDropTime = currentTime;
              this.spawnDrop();
              updateLiquidLevels();
            }
          } else {
            isPouring = false;
          }
          
          if (tilt > 40 && tubeAVisible && tubeBVisible && !reactionDone) {
            if (levelA <= MIN + 0.01) {
              triggerReaction();
            }
          }
        });
      },

      spawnDrop: function () {
        dropCount++;
        document.getElementById("drop-count").textContent = dropCount;
        
        const drop = document.createElement("a-sphere");
        drop.setAttribute("radius", "0.03");
        drop.setAttribute("color", "#0088ff");
        drop.setAttribute("opacity", "0.9");
        
        const tubeA = document.querySelector("#tubeA");
        if (!tubeA) return;
        
        drop.setAttribute("position", { x: 0, y: levelA + 0.1, z: 0 });
        
        drop.setAttribute("light", {
          type: "point",
          color: "#0088ff",
          intensity: 0.5,
          distance: 0.5
        });
        
        tubeA.appendChild(drop);
        
        const dropId = 'drop-' + Date.now();
        drop.setAttribute('id', dropId);
        activeDrops.push({id: dropId, element: drop});
        
        this.animateDrop(drop, dropId);
      },

      animateDrop: function (drop, dropId) {
        let currentY = levelA + 0.1;
        const velocity = { x: 0, y: -0.015, z: 0 };
        const gravity = 0.0008;
        
        const animate = () => {
          if (!reactionDone) {
            velocity.y -= gravity;
            currentY += velocity.y;
            
            drop.setAttribute("position", {
              x: 0,
              y: currentY,
              z: 0
            });
            
            const wobble = Math.sin(Date.now() * 0.01) * 0.008;
            drop.setAttribute("position", {
              x: wobble,
              y: currentY,
              z: wobble * 0.5
            });
            
            if (currentY < -0.2) {
              if (drop.parentNode) drop.parentNode.removeChild(drop);
              const index = activeDrops.findIndex(d => d.id === dropId);
              if (index > -1) activeDrops.splice(index, 1);
              return;
            }
            
            requestAnimationFrame(animate);
          } else {
            if (drop.parentNode) drop.parentNode.removeChild(drop);
            const index = activeDrops.findIndex(d => d.id === dropId);
            if (index > -1) activeDrops.splice(index, 1);
          }
        };
        
        requestAnimationFrame(animate);
      }
    });

    // Update liquid levels
    function updateLiquidLevels() {
      if (!tubeAVisible || !tubeBVisible || reactionDone) return;
      
      const liquidA = document.querySelector("#liquidA");
      const liquidB = document.querySelector("#liquidB");
      if (!liquidA || !liquidB) return;

      if (levelA > MIN) {
        levelA -= SPEED * 0.7; // Faster pouring
        levelB += SPEED * 0.7;
      }

      levelA = Math.max(MIN, levelA);
      levelB = Math.min(MAX, levelB);

      // Update Tube A
      liquidA.setAttribute("height", levelA);
      liquidA.setAttribute("position", `0 ${levelA / 2} 0`);

      // Update Tube B
      liquidB.setAttribute("height", levelB);
      liquidB.setAttribute("position", `0 ${levelB / 2} 0`);
      
      // Update liquid surfaces
      const surfaceA = document.querySelector("#surfaceA");
      const surfaceB = document.querySelector("#surfaceB");
      if (surfaceA) surfaceA.setAttribute('position', `0 ${levelA} 0`);
      if (surfaceB) surfaceB.setAttribute('position', `0 ${levelB} 0`);
    }

    // TRIGGER REACTION - SUPER DRAMATIC
    function triggerReaction() {
      reactionDone = true;
      
      // Fill Tube B completely for dramatic effect
      levelB = MAX;
      const liquidB = document.querySelector("#liquidB");
      if (liquidB) {
        liquidB.setAttribute("height", levelB);
        liquidB.setAttribute("position", `0 ${levelB / 2} 0`);
        liquidB.setAttribute("color", "#ffff00");
        const surfaceB = document.querySelector("#surfaceB");
        if (surfaceB) surfaceB.setAttribute('position', `0 ${levelB} 0`);
      }
      
      // Update status with dramatic text
      document.getElementById("reaction-status").innerHTML = "üí• <strong>EXPLOSIVE REACTION!</strong> üí•";
      document.getElementById("reaction-status").style.animation = "rainbow 0.8s infinite, rainbowGlow 0.8s infinite";
      document.getElementById("reaction-status").style.fontSize = "16px";
      
      // Clear all drops
      clearAllDrops();
      
      // SHAKE the entire UI
      document.getElementById("hud").style.animation = "shake 1s 3";
      
      // Start SUPER DRAMATIC reaction
      const tubeA = document.querySelector("#tubeA");
      if (tubeA && tubeA.components["reaction-system"]) {
        tubeA.components["reaction-system"].startReaction();
        
        // After 3 seconds of intense reaction, transition to continuous mode
        setTimeout(() => {
          if (tubeA.components["reaction-system"]) {
            tubeA.components["reaction-system"].transitionToContinuousMode();
            document.getElementById("reaction-status").innerHTML = "üåà <strong>CONTINUOUS RAINBOW FLOW!</strong> üåà";
            document.getElementById("hud").style.animation = "";
          }
        }, 3000);
      }
    }

    function clearAllDrops() {
      activeDrops.forEach(drop => {
        if (drop.element.parentNode) {
          drop.element.parentNode.removeChild(drop.element);
        }
      });
      activeDrops = [];
    }

    function updateStatus() {
      const status = document.getElementById("experiment-status");
      if (tubeAVisible && tubeBVisible) {
        status.textContent = "Ready! Tilt phone forward to pour";
      } else if (tubeAVisible) {
        status.textContent = "Tube A ready - Half full";
      } else if (tubeBVisible) {
        status.textContent = "Tube B ready - Small amount";
      } else {
        status.textContent = "Show marker A or B";
      }
    }

    // Reset function
    window.resetExperiment = function() {
      reactionDone = false;
      dropCount = 0;
      levelA = 0.25; // Reset to half full
      levelB = 0.1;  // Reset to small amount
      isPouring = false;
      reactionAnimationActive = false;
      isReactionComplete = false;
      
      // Reset tube A
      const tubeA = document.querySelector("#tubeA");
      if (tubeA) {
        tubeA.setAttribute('rotation', '0 0 0');
        tubeA.setAttribute('scale', '1 1 1');
        tubeA.setAttribute('position', '0 0 0');
        
        if (tubeA.components["reaction-system"]) {
          tubeA.components["reaction-system"].stopAllEffects();
        }
      }
      
      // Reset tube B
      const tubeB = document.querySelector("#tubeB");
      if (tubeB) {
        tubeB.setAttribute('rotation', '0 0 0');
        tubeB.setAttribute('scale', '1 1 1');
        tubeB.setAttribute('position', '0 0 0');
      }
      
      // Reset liquids to visible state
      updateTubeALiquidVisibility();
      updateTubeBLiquidVisibility();
      
      // Reset glass color
      const glass = document.querySelector("#tubeA a-cylinder");
      if (glass) {
        glass.setAttribute('color', '#ffffff');
        glass.setAttribute('emissive', '#000000');
        glass.setAttribute('emissive-intensity', '0');
      }
      
      // Clear drops and particles
      clearAllDrops();
      reactionParticles.forEach(p => {
        if (p.element.parentNode) p.element.parentNode.removeChild(p.element);
      });
      reactionParticles = [];
      reactionSparkles.forEach(s => {
        if (s.element.parentNode) s.element.parentNode.removeChild(s.element);
      });
      reactionSparkles = [];
      
      // Update UI
      document.getElementById("drop-count").textContent = "0";
      document.getElementById("reaction-status").innerHTML = "Not reacted";
      document.getElementById("reaction-status").style.animation = "none";
      document.getElementById("reaction-status").style.fontSize = "";
      document.getElementById("reaction-status").style.color = "white";
      document.getElementById("hud").style.animation = "";
      document.getElementById("tilt-display").textContent = "0¬∞";
      
      updateStatus();
    };

  </script>

</head>

<body style="margin:0; overflow:hidden;">
  <!-- HUD Display -->
  <div id="hud">
    <h3 style="margin: 0 0 10px 0;">üß™ AR Chemical Experiment</h3>
    <p><strong>Status:</strong> <span id="experiment-status">Show marker A or B</span></p>
    <p><strong>Tilt:</strong> <span id="tilt-display">0¬∞</span></p>
    <p><strong>Pouring:</strong> <span id="pouring-status">No</span></p>
    <p><strong>Markers:</strong> 
      A: <span id="marker-a-status">‚ùå</span> | 
      B: <span id="marker-b-status">‚ùå</span>
    </p>
    <p><strong>Reaction:</strong> <span id="reaction-status">Not reacted</span></p>
    <button onclick="resetExperiment()" style="margin-top: 5px; padding: 5px 10px;">
      Reset Experiment
    </button>
  </div>
  
  <!-- Drop Counter -->
  <div class="drop-counter">
    üíß Drops: <span id="drop-count">0</span>
  </div>

  <a-scene
    embedded
    arjs="debugUIEnabled:false;"
    device-orientation-permission-ui="enabled: true">

    <!-- Lighting -->
    <a-light type="ambient" intensity="0.8"></a-light>
    <a-light type="directional" position="1 2 1" intensity="0.6"></a-light>

    <!-- ========== TEST TUBE A (Half Full Blue Liquid) ========= -->
    <a-marker
      type="pattern"
      url="markers/testtube_markerA.patt"
      marker-tracker="id: A">

      <a-entity id="tubeA" drop-spawner reaction-system="tubeId: A" particle-animator position="0 0 0">
        <!-- Glass -->
        <a-cylinder
          radius="0.15"
          height="0.5"
          position="0 0.25 0"
          color="#ffffff"
          opacity="0.25"
          roughness="0.1"
          metalness="0.5">
        </a-cylinder>

        <!-- Liquid A - HALF FULL FROM START -->
        <a-cylinder
          id="liquidA"
          radius="0.13"
          height="0.25"
          position="0 0.125 0"
          color="#0088ff"
          opacity="0.95"
          roughness="0.2"
          metalness="0.1"
          emissive="#000000"
          emissive-intensity="0"
          transparent="true">
        </a-cylinder>

        <!-- Liquid surface -->
        <a-circle
          id="surfaceA"
          radius="0.13"
          position="0 0.25 0"
          color="#0088ff"
          opacity="0.95"
          rotation="-90 0 0"
          transparent="true">
        </a-circle>

      </a-entity>

    </a-marker>

    <!-- ========== TEST TUBE B (Small Yellow Liquid) ========= -->
    <a-marker
      type="pattern"
      url="markers/testtube_markerB.patt"
      marker-tracker="id: B">

      <a-entity id="tubeB" position="0 0 0">
        <!-- Glass -->
        <a-cylinder
          radius="0.15"
          height="0.5"
          position="0 0.25 0"
          color="#ffffff"
          opacity="0.25"
          roughness="0.1"
          metalness="0.5">
        </a-cylinder>

        <!-- Liquid B - SMALL AMOUNT FROM START -->
        <a-cylinder
          id="liquidB"
          radius="0.13"
          height="0.1"
          position="0 0.05 0"
          color="#ffff00"
          opacity="0.95"
          roughness="0.2"
          metalness="0.1"
          transparent="true">
        </a-cylinder>

        <!-- Liquid surface -->
        <a-circle
          id="surfaceB"
          radius="0.13"
          position="0 0.1 0"
          color="#ffff00"
          opacity="0.95"
          rotation="-90 0 0"
          transparent="true">
        </a-circle>

      </a-entity>

    </a-marker>

    <!-- Camera -->
    <a-entity camera></a-entity>
  </a-scene>
  
  <script>
    // Update UI
    setInterval(() => {
      const pouringStatus = document.getElementById("pouring-status");
      pouringStatus.textContent = isPouring ? "Yes" : "No";
      pouringStatus.style.color = isPouring ? "#00ff00" : "white";
      pouringStatus.style.fontWeight = isPouring ? "bold" : "normal";
      
      if (isReactionComplete) {
        document.getElementById("reaction-status").style.animation = "rainbow 1.5s infinite, rainbowGlow 1.5s infinite";
      }
    }, 100);
  </script>
</body>
</html>
